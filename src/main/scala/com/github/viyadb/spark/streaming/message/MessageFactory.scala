package com.github.viyadb.spark.streaming.message

import com.github.viyadb.spark.TableConfig
import org.apache.spark.rdd.RDD
import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.types._

abstract class MessageFactory(table: TableConfig.Table) extends Serializable {

  lazy val schema = createSchema()

  protected def createSchema(): StructType = {
    val dimsSchema = (table.batch.timeColumn.map(_.name).toList
      ++ table.dimensions.map(_.name)
      ++ table.metrics.filter(_.`type` == "bitset").map(_.name))
      .distinct.map(f => (f, StructField(f, StringType)))

    val metricsSchema = table.metrics.filter(_.`type` != "bitset").map { metric =>
      (metric.name, StructField(metric.name, metric.`type` match {
        case "count" => LongType
        case other => other.split("_")(0) match {
          case "int" | "uint" => IntegerType
          case "long" | "ulong" => LongType
          case "double" => DoubleType
        }
      }))
    }

    val colsToSchema = (dimsSchema ++ metricsSchema).toMap

    val fieldsSchema = if (table.realTime.parseSpec.nonEmpty && table.realTime.parseSpec.get.columns.nonEmpty) {
      table.realTime.parseSpec.get.columns.get.map(col => colsToSchema.get(col).get)
    } else {
      colsToSchema.values.toSeq
    }

    StructType(fieldsSchema)
  }

  /**
    * Handle message once it's recieved prior to storing it in a batch
    *
    * @param meta Some metadata (topic in case of Kafka)
    * @param msg  Received message
    * @return whatever the message is converted to
    */
  def handleMessage(meta: String, msg: String): AnyRef = msg

  /**
    * Creates Spark data frame based on RDD of "anything else" generated by the early handler.
    *
    * @see createEarlyHandler
    * @param rdd Input RDD of "anything else"
    * @return Data frame
    */
  def createDataFrame(rdd: RDD[AnyRef]): DataFrame
}

object MessageFactory {
  def create(table: TableConfig.Table): MessageFactory = {
    if (table.realTime.messageFactoryClass.nonEmpty) {
      Class.forName(table.realTime.messageFactoryClass.get)
        .getDeclaredConstructor(classOf[TableConfig.Table]).newInstance(table).asInstanceOf[MessageFactory]
    } else {
      if (table.realTime.parseSpec.isEmpty) {
        throw new IllegalArgumentException("Either messageFactoryClass or parseSpec must be specified!")
      }
      table.realTime.parseSpec.get.format match {
        case "tsv" => new TsvMessageFactory(table)
        case "json" => new JsonMessageFactory(table)
        case _ => throw new IllegalArgumentException("Unsupported message format specified in parse spec!")
      }
    }
  }
}